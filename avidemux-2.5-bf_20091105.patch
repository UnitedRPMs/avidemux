Index: cmake/patches/libavformat_flvenc.c.patch
===================================================================
--- cmake/patches/libavformat_flvenc.c.patch	(révision 5371)
+++ cmake/patches/libavformat_flvenc.c.patch	(copie de travail)
@@ -1,7 +1,7 @@
-*** libavformat/flvenc.c.old	Thu Sep 17 16:14:10 2009
---- libavformat/flvenc.c	Thu Sep 17 16:14:10 2009
+*** libavformat/flvenc.c.old	Sun Oct 18 17:15:09 2009
+--- libavformat/flvenc.c	Sun Oct 18 17:15:09 2009
 ***************
-*** 389,395 ****
+*** 405,411 ****
       "video/x-flv",
       "flv",
       sizeof(FLVContext),
@@ -9,7 +9,7 @@
       CODEC_ID_MP3,
   #else // CONFIG_LIBMP3LAME
       CODEC_ID_ADPCM_SWF,
---- 389,396 ----
+--- 405,412 ----
       "video/x-flv",
       "flv",
       sizeof(FLVContext),
@@ -19,8 +19,8 @@
   #else // CONFIG_LIBMP3LAME
       CODEC_ID_ADPCM_SWF,
 ***************
-*** 401,403 ****
---- 402,410 ----
+*** 417,419 ****
+--- 418,426 ----
       .codec_tag= (const AVCodecTag* const []){flv_video_codec_ids, flv_audio_codec_ids, 0},
       .flags= AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS,
   };
Index: cmake/patches/libavcodec_utils.c.patch
===================================================================
--- cmake/patches/libavcodec_utils.c.patch	(révision 5371)
+++ cmake/patches/libavcodec_utils.c.patch	(copie de travail)
@@ -1,8 +1,8 @@
-*** libavcodec/utils.c.old	Thu Sep 17 16:14:07 2009
---- libavcodec/utils.c	Thu Sep 17 16:14:07 2009
+*** libavcodec/utils.c.old	Sun Oct 18 17:15:08 2009
+--- libavcodec/utils.c	Sun Oct 18 17:15:08 2009
 ***************
-*** 611,620 ****
---- 611,622 ----
+*** 631,640 ****
+--- 631,642 ----
   
       if((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size){
           //FIXME remove the check below _after_ ensuring that all audio check that the available space is enough
@@ -16,7 +16,7 @@
           *frame_size_ptr < avctx->channels * avctx->frame_size * sizeof(int16_t)){
               av_log(avctx, AV_LOG_ERROR, "buffer %d too small\n", *frame_size_ptr);
 ***************
-*** 1049,1055 ****
+*** 1071,1077 ****
           return -1;
       }
   #if !HAVE_MKSTEMP
@@ -24,7 +24,7 @@
   #else
       snprintf(*filename, len, "/tmp/%sXXXXXX", prefix);
       fd = mkstemp(*filename);
---- 1051,1057 ----
+--- 1073,1079 ----
           return -1;
       }
   #if !HAVE_MKSTEMP
Index: cmake/patches/libavcodec_avcodec.h.patch
===================================================================
--- cmake/patches/libavcodec_avcodec.h.patch	(révision 5371)
+++ cmake/patches/libavcodec_avcodec.h.patch	(copie de travail)
@@ -1,8 +1,8 @@
-*** libavcodec/avcodec.h.old	Thu Sep 17 16:13:53 2009
---- libavcodec/avcodec.h	Thu Sep 17 16:13:53 2009
+*** libavcodec/avcodec.h.old	Sun Oct 18 17:15:04 2009
+--- libavcodec/avcodec.h	Sun Oct 18 17:15:04 2009
 ***************
-*** 572,577 ****
---- 572,579 ----
+*** 573,578 ****
+--- 573,580 ----
   #define CODEC_FLAG2_CHUNKS        0x00008000 ///< Input bitstream might be truncated at a packet boundaries instead of only at frame boundaries.
   #define CODEC_FLAG2_NON_LINEAR_QUANT 0x00010000 ///< Use MPEG-2 nonlinear quantizer.
   #define CODEC_FLAG2_BIT_RESERVOIR 0x00020000 ///< Use a bit reservoir when encoding if possible
@@ -12,8 +12,8 @@
   /* Unsupported options :
    *              Syntax Arithmetic coding (SAC)
 ***************
-*** 1430,1435 ****
---- 1432,1438 ----
+*** 1431,1436 ****
+--- 1433,1439 ----
        * - decoding: unused
        */
       int rc_max_rate;
@@ -22,8 +22,8 @@
       /**
        * minimum bitrate
 ***************
-*** 1444,1449 ****
---- 1447,1454 ----
+*** 1445,1450 ****
+--- 1448,1455 ----
        * - decoding: unused
        */
       int rc_buffer_size;
Index: cmake/patches/libavcodec_mpeg12enc.c.patch
===================================================================
--- cmake/patches/libavcodec_mpeg12enc.c.patch	(révision 5371)
+++ cmake/patches/libavcodec_mpeg12enc.c.patch	(copie de travail)
@@ -1,5 +1,5 @@
-*** libavcodec/mpeg12enc.c.old	Thu Aug 27 21:16:08 2009
---- libavcodec/mpeg12enc.c	Thu Aug 27 21:16:09 2009
+*** libavcodec/mpeg12enc.c.old	Sun Oct 18 17:15:07 2009
+--- libavcodec/mpeg12enc.c	Sun Oct 18 17:15:07 2009
 ***************
 *** 127,136 ****
 --- 127,145 ----
@@ -128,8 +128,8 @@
                   put_bits(&s->pb, 2, s->width >>12);
                   put_bits(&s->pb, 2, s->height>>12);
 ***************
-*** 334,339 ****
---- 377,384 ----
+*** 339,344 ****
+--- 382,389 ----
   
   void mpeg1_encode_picture_header(MpegEncContext *s, int picture_number)
   {
@@ -139,8 +139,8 @@
   
       /* mpeg1 picture header */
 ***************
-*** 370,375 ****
---- 415,463 ----
+*** 375,380 ****
+--- 420,468 ----
   
       s->frame_pred_frame_dct = 1;
       if(s->codec_id == CODEC_ID_MPEG2VIDEO){
@@ -191,8 +191,8 @@
           put_bits(&s->pb, 4, 8); //pic ext
           if (s->pict_type == FF_P_TYPE || s->pict_type == FF_B_TYPE) {
 ***************
-*** 388,398 ****
---- 476,491 ----
+*** 393,403 ****
+--- 481,496 ----
   
           assert(s->picture_structure == PICT_FRAME);
           put_bits(&s->pb, 2, s->picture_structure);
@@ -210,7 +210,7 @@
              measures */
           s->frame_pred_frame_dct = s->progressive_sequence;
 ***************
-*** 402,408 ****
+*** 407,413 ****
           put_bits(&s->pb, 1, s->q_scale_type);
           put_bits(&s->pb, 1, s->intra_vlc_format);
           put_bits(&s->pb, 1, s->alternate_scan);
@@ -218,7 +218,7 @@
           s->progressive_frame = s->progressive_sequence;
           put_bits(&s->pb, 1, s->chroma_format == CHROMA_420 ? s->progressive_frame : 0); /* chroma_420_type */
           put_bits(&s->pb, 1, s->progressive_frame);
---- 495,504 ----
+--- 500,509 ----
           put_bits(&s->pb, 1, s->q_scale_type);
           put_bits(&s->pb, 1, s->intra_vlc_format);
           put_bits(&s->pb, 1, s->alternate_scan);
Index: cmake/patches/libavformat_matroskaenc.c.patch
===================================================================
--- cmake/patches/libavformat_matroskaenc.c.patch	(révision 5371)
+++ cmake/patches/libavformat_matroskaenc.c.patch	(copie de travail)
@@ -1,5 +1,5 @@
-*** libavformat/matroskaenc.c.old	Sat Jun 27 18:45:28 2009
---- libavformat/matroskaenc.c	Sat Jun 27 18:45:28 2009
+*** libavformat/matroskaenc.c.old	Sun Oct 18 17:15:09 2009
+--- libavformat/matroskaenc.c	Sun Oct 18 17:15:10 2009
 ***************
 *** 395,400 ****
 --- 395,401 ----
@@ -68,8 +68,8 @@
           if ((tag = av_metadata_get(st->metadata, "description", NULL, 0)))
               put_ebml_string(pb, MATROSKA_ID_TRACKNAME, tag->value);
 ***************
-*** 907,909 ****
---- 947,959 ----
+*** 954,956 ****
+--- 994,1006 ----
       .flags = AVFMT_GLOBALHEADER,
       .codec_tag = (const AVCodecTag* const []){ff_codec_wav_tags, 0},
   };
Index: cmake/patches/libavcodec_h264.c.patch
===================================================================
--- cmake/patches/libavcodec_h264.c.patch	(révision 5371)
+++ cmake/patches/libavcodec_h264.c.patch	(copie de travail)
@@ -1,8 +1,8 @@
-*** libavcodec/h264.c.old	Sun Aug  2 10:23:00 2009
---- libavcodec/h264.c	Sun Aug  2 10:23:00 2009
+*** libavcodec/h264.c.old	Sun Oct 18 17:15:06 2009
+--- libavcodec/h264.c	Sun Oct 18 17:15:06 2009
 ***************
-*** 8155,8160 ****
---- 8155,8171 ----
+*** 8159,8164 ****
+--- 8159,8175 ----
       return 0;
   }
   
Index: plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp
===================================================================
--- plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp	(révision 5371)
+++ plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp	(copie de travail)
@@ -61,7 +61,7 @@
 
   static char *pcm_name;
 //  if( prefs->get(DEVICE_AUDIO_ALSA_DEVICE, &pcm_name) != RC_OK )
-               pcm_name = ADM_strdup("dmix");
+               pcm_name = ADM_strdup("default");
     printf("[Alsa] Using device :%s\n",pcm_name);
  /* Allocate the snd_pcm_hw_params_t structure on the stack. */
     snd_pcm_hw_params_alloca(&hwparams);
Index: plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp
===================================================================
--- plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp	(révision 5371)
+++ plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp	(copie de travail)
@@ -172,11 +172,15 @@
     {
     default:
     case ADM_LAME_PRESET_CBR:
+          lame_set_VBR(MYFLAGS, vbr_off);
       break;
     case ADM_LAME_PRESET_ABR:
 
-      lame_set_preset (MYFLAGS, lameConf->bitrate);
+     // lame_set_preset (MYFLAGS, lameConf->bitrate);
       _wavheader->blockalign = BLOCK_SIZE;
+       lame_set_VBR(MYFLAGS, vbr_abr);
+       lame_set_VBR_mean_bitrate_kbps(MYFLAGS, lameConf->bitrate);
+
       break;
     case ADM_LAME_PRESET_EXTREME:
       _wavheader->blockalign = BLOCK_SIZE;
@@ -197,7 +201,7 @@
     @return 1 if the stream is vbr, 0 is cbr
 
 */
-uint8_t AUDMEncoder_Lame::isVBR (void)
+bool AUDMEncoder_Lame::isVBR (void)
 {
   if (myLameParam.preset == ADM_LAME_PRESET_CBR)
     return 0;
Index: plugins/ADM_audioEncoders/lame/audioencoder_lame.h
===================================================================
--- plugins/ADM_audioEncoders/lame/audioencoder_lame.h	(révision 5371)
+++ plugins/ADM_audioEncoders/lame/audioencoder_lame.h	(copie de travail)
@@ -27,7 +27,7 @@
 //            uint8_t     init(ADM_audioEncoderDescriptor *config);
     virtual             ~AUDMEncoder_Lame();
                         AUDMEncoder_Lame(AUDMAudioFilter *instream);	
-            uint8_t	isVBR(void );
+   virtual bool	    isVBR(void );
             
    virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
    virtual uint8_t  initialize(void);
Index: plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Options.cpp
===================================================================
--- plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Options.cpp	(révision 5371)
+++ plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Options.cpp	(copie de travail)
@@ -330,12 +330,20 @@
 
 bool x264Options::getBFrameReferences(void)
 {
+#if X264_BUILD >= 78
+	return _param.i_bframe_pyramid;
+#else
 	return _param.b_bframe_pyramid;
+#endif
 }
 
 void x264Options::setBFrameReferences(bool bFrameReferences)
 {
+#if X264_BUILD >= 78
+	_param.i_bframe_pyramid = bFrameReferences;
+#else
 	_param.b_bframe_pyramid = bFrameReferences;
+#endif
 }
 
 bool x264Options::getLoopFilter(void)
Index: plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
===================================================================
--- plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	(révision 5371)
+++ plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	(copie de travail)
@@ -625,7 +625,11 @@
 	printf("[x264] i_bframe = %d\n", x264Param->i_bframe);
 	printf("[x264] i_bframe_bias = %d\n", x264Param->i_bframe_bias);
 	printf("[x264] i_frame_reference = %d\n", x264Param->i_frame_reference);
+#if X264_BUILD >= 78
+	printf("[x264] i_bframe_pyramid = %d\n", x264Param->i_bframe_pyramid);
+#else
 	printf("[x264] b_bframe_pyramid = %d\n", x264Param->b_bframe_pyramid);
+#endif
 #if X264_BUILD >= 63
 	printf("[x264] i_bframe_adaptive = %d\n", x264Param->i_bframe_adaptive);
 #else
Index: avidemux/ADM_audiocodec/ADM_codecwma.cpp
===================================================================
--- avidemux/ADM_audiocodec/ADM_codecwma.cpp	(révision 5371)
+++ avidemux/ADM_audiocodec/ADM_codecwma.cpp	(copie de travail)
@@ -57,6 +57,7 @@
     // Fills in some values...
     _context->sample_rate = info->frequency;
     _context->channels = info->channels;
+    _channels=info->channels;
     _blockalign=_context->block_align = info->blockalign;
     _context->bit_rate = info->byterate*8;
     switch(fourcc)
@@ -163,6 +164,19 @@
           {
             *outptr++=((float)run16[i])/32767.;
           }
+         if(_channels>=5 )
+            {
+            CHANNEL_TYPE *p_ch_type = channelMapping;
+        #define DOIT(x,y) if(_context->channel_layout & CH_##x) *(p_ch_type++)=CHTYP_##y;
+                DOIT(LOW_FREQUENCY,LFE);
+                DOIT(FRONT_LEFT,FRONT_LEFT);
+                DOIT(FRONT_CENTER,FRONT_CENTER);
+                DOIT(FRONT_RIGHT,FRONT_RIGHT);
+                DOIT(SIDE_LEFT,REAR_LEFT);
+                DOIT(SIDE_RIGHT,REAR_RIGHT);
+
+            }
+
         }
         
         
Index: avidemux/ADM_audiocodec/ADM_audiocodec.h
===================================================================
--- avidemux/ADM_audiocodec/ADM_audiocodec.h	(révision 5371)
+++ avidemux/ADM_audiocodec/ADM_audiocodec.h	(copie de travail)
@@ -109,6 +109,7 @@
 		uint8_t _buffer[ ADMWA_BUF];
 		uint32_t _tail,_head;
 		uint32_t _blockalign;
+                uint32_t _channels;
 
 	public:
 		ADM_AudiocodecWMA(uint32_t fourcc, WAVHeader *info, uint32_t l, uint8_t *d);
Index: avidemux/ADM_audiofilter/audio_encoderWrapper.cpp
===================================================================
--- avidemux/ADM_audiofilter/audio_encoderWrapper.cpp	(révision 5371)
+++ avidemux/ADM_audiofilter/audio_encoderWrapper.cpp	(copie de travail)
@@ -78,5 +78,13 @@
     return _encoder->extraData(l,d);
 
 }
-
+/**
+    \fn isVBR
+    \brief Trampoline
+*/
+uint8_t  	ADM_audioEncoderWrapper::isVBR(void )
+{
+    ADM_assert(_encoder);
+    return _encoder->isVBR();
+}
 //EOF
\ No newline at end of file
Index: avidemux/ADM_audiofilter/audio_encoderWrapper.h
===================================================================
--- avidemux/ADM_audiofilter/audio_encoderWrapper.h	(révision 5371)
+++ avidemux/ADM_audiofilter/audio_encoderWrapper.h	(copie de travail)
@@ -20,6 +20,7 @@
         virtual uint8_t		goTo(uint32_t offset) {ADM_assert(0);return 0;} // Not supposed to seek..
         virtual uint32_t	read(uint32_t size,uint8_t *ptr);
         virtual uint8_t		extraData(uint32_t *l,uint8_t **d);
+        virtual uint8_t  	isVBR(void ) ;
 };
 
 #endif
Index: avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
===================================================================
--- avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	(révision 5371)
+++ avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	(copie de travail)
@@ -437,7 +437,7 @@
                  {
                       get_se_golomb(&s);
                  }
-             }else 
+             }else if(pic_order_cnt_type!=2)
              {
                printf("Error in SPS\n");
                return 0;
@@ -706,4 +706,4 @@
     	return 1; 
     }   
 	return 1;
-}
\ No newline at end of file
+}
Index: avidemux/ADM_coreImage/include/ADM_videoFilter_internal.h
===================================================================
--- avidemux/ADM_coreImage/include/ADM_videoFilter_internal.h	(révision 5371)
+++ avidemux/ADM_coreImage/include/ADM_videoFilter_internal.h	(copie de travail)
@@ -33,7 +33,7 @@
 }VF_CATEGORY;
 #define VF_INVALID 		  0
 
-#define VF_PARTIAL_FILTER 9
+#define VF_PARTIAL_FILTER  filterGetTagFromName( "partial" )
 #define VF_START_TAG 	  10
 
 typedef uint32_t VF_FILTERS ;
Index: avidemux/ADM_codecs/ADM_codecs.cpp
===================================================================
--- avidemux/ADM_codecs/ADM_codecs.cpp	(révision 5371)
+++ avidemux/ADM_codecs/ADM_codecs.cpp	(copie de travail)
@@ -77,6 +77,7 @@
   CHECK ("BLZ0");
   CHECK ("M4S2");
   CHECK ("3IV2");
+  CHECK ("SEDG");
 
   return divx4;
 
Index: avidemux/ADM_audio/ADM_dcainfo.cpp
===================================================================
--- avidemux/ADM_audio/ADM_dcainfo.cpp	(révision 5371)
+++ avidemux/ADM_audio/ADM_dcainfo.cpp	(copie de travail)
@@ -102,8 +102,13 @@
 #endif
                 *syncoff=cur-buf;
                 if(*syncoff) printf("[dts] Dropped %u bytes\n",*syncoff);
-                *chan=dts_channels[flags & 0xf];
-//                if(*chan==5 && (flags & 0X80)) *chan++;
+                get_bits(&s,10);
+                int lfe=get_bits(&s,2);
+                int c;
+                c=dts_channels[flags & 0xf];
+                if(c==5 && lfe) c++; // LFE
+                *chan=c;
+
                 *nbSample=nbBlocks*32;
                 return framesize;
                 
Index: avidemux/ADM_coreAudio/include/audioencoder.h
===================================================================
--- avidemux/ADM_coreAudio/include/audioencoder.h	(révision 5371)
+++ avidemux/ADM_coreAudio/include/audioencoder.h	(copie de travail)
@@ -72,6 +72,7 @@
     virtual uint8_t packetPerFrame( void) {return 1;}
     virtual uint8_t extraData(uint32_t *l,uint8_t **d) {*l=_extraSize;*d=_extraData;return 1;}
             uint8_t  goTo(uint32_t timeMS) {ADM_assert(0);return 1;}
+    virtual bool    isVBR(void) {return false;}
 };
 // Used by some old code (lame/twolame) OBSOLETE   / DO NOT USE
 typedef enum  
